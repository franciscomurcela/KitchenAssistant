<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EVAL Dashboard</title>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
  <!-- ECharts -->
  <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
  <style>
    :root {
      --sidebar-bg: #333;
      --sidebar-text: #fff;
      --sidebar-hover: #444;
      --btn-border: #fff;
      --body-text: #333;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      color: var(--body-text);
      background: linear-gradient(-45deg,#f3e6e8,#d4e4f7,#e8f7d4,#f7e8d4);
      background-size:400% 400%;
      animation:gradientAnimation 15s ease infinite;
      scroll-behavior:smooth;
    }
    @keyframes gradientAnimation { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
    .sidebar {
      position: fixed; top:0; left:0; bottom:0;
      width:300px; background: linear-gradient(to bottom, rgba(51, 51, 51, 1), rgba(51, 51, 51, 0.6)); /* More intense and gradual fade effect */
      color:var(--sidebar-text);
      display:flex; flex-direction:column; justify-content:space-between;
      padding:20px 0;
    }
    .sidebar-header {
      padding-top: 10px; /* Reduced top padding to move the title slightly upwards */
      padding-bottom: 24px;
      text-align:center;
      border-bottom:1px solid var(--sidebar-hover);
    }
    .sidebar-header h2 {
        margin-bottom: 0; /* Remove extra margin below the title */
    }
    .sidebar-header h3 {
        margin-top: 0; /* Ensure no extra margin above the subtitle */
        font-size: 1.2rem; /* Slightly smaller font size for subtitle */
        color: #ccc; /* Lighter color for subtitle */
    }
    .sidebar-nav {
        margin-top: 20px; /* Added margin to push buttons slightly downward */
    }
    .sidebar-nav a {
      display:block; padding:16px 24px; margin-bottom:8px;
      color:var(--sidebar-text); text-decoration:none;
      font-size: 1.2rem; /* Ensure base font size is consistent */
      transition: font-size 0.2s ease, color 0.2s ease;
    }
    .sidebar-nav a:hover {
        background: rgba(255, 255, 255, 0.201); /* Lighter hover effect */
        box-shadow: none; /* Removed shadow for a subtle effect */
        transform: scale(1.03); /* Slight scaling without exceeding sidebar limits */
        font-size: 1.3rem; /* Ensure text size increases slightly on hover */
    }
    .sidebar-nav a.active { font-weight:bold; background: var(--sidebar-hover); }
    .sidebar-nav a.active:hover {
        transform: none; /* Prevent scaling for the active button */
    }
    .btn-logout {
      margin:0 24px; padding:12px; font-size:1.2rem;
      color: #fff; /* White text for contrast */
      background-color: #830a0a6d; /* Red background for logout button */
      border:1px solid var(--btn-border); border-radius:4px;
      cursor: pointer;
    }
    .btn-logout:hover {
        background-color: #63040467; /* Darker red on hover */
    }
    main.content { margin-left:300px; padding:60px; }
    .chart-box {
      background:#fff; border-radius:12px;
      box-shadow:0 6px 12px rgba(0,0,0,0.1);
      padding:36px; margin:0 auto 150px;
      max-width:900px;
    }
    .chart-title { font-size:2.5rem; margin-bottom:32px; text-align:center; color:#444; }
    .chart-group { display:flex; flex-wrap:wrap; gap:50px; justify-content:center; }
    .chart-item { flex:1; min-width:280px; text-align:center; }
    #gaugeChart {
      height: 500px !important;
    }
    canvas, #randomLineChart, #stackedLineChart {
      width:100%; height:500px;
    }
    #justificacoes-container { max-height:500px; overflow-y:auto; margin-top:24px; }
    .filter-row { display:flex; flex-wrap:wrap; gap:16px; justify-content:center; margin-bottom:16px; }
    .filter-row label, .filter-row select, .filter-row input, .filter-row button { font-size:1rem; }
    .filter-row button { padding:8px 16px; cursor:pointer; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:12px; border:1px solid #ddd; font-size:1rem; text-align:left; }
    th { background:#f2f2f2; }
    tr:nth-child(odd) { background:#f9f9f9; }
    /* Custom Switches (visual igual ao exemplo da imagem) */
.custom-switch-group {
  display: flex;
  align-items: center;
}
.custom-switch {
  position: relative;
  display: flex;
  align-items: center;
  background: #ededed;
  border-radius: 999px;
  border: 1.5px solid #ccc;
  padding: 3px 6px;
  min-width: 110px;
  height: 38px;
  box-sizing: border-box;
  cursor: pointer;
  transition: border 0.2s;
  user-select: none;
}
.custom-switch .switch-option {
  position: relative;
  z-index: 2;
  flex: 1 1 0;
  text-align: center;
  font-size: 1.25rem;
  font-weight: 700;
  color: #555;
  transition: color 0.2s;
  cursor: pointer;
  padding: 0 8px;
  line-height: 32px;
}
.custom-switch .switch-option.active {
  color: #2196f3;
  font-weight: 700;
}
.custom-switch .switch-slider {
  position: absolute;
  top: 3px;
  left: 3px;
  width: calc(50% - 3px);
  height: 32px;
  background: #cbe3f8;
  border-radius: 999px;
  box-shadow: 0 1px 4px #0001;
  transition: left 0.22s cubic-bezier(.4,1.4,.6,1), background 0.2s;
  z-index: 1;
  opacity: 0.85;
}
/* Ajuste para switches com 2 opções */
.custom-switch[data-active="1"] .switch-slider {
  left: calc(50% + 3px);
  background: #cbe3f8;
}
.custom-switch .switch-option {
  font-size: 1.15rem;
  font-weight: 600;
  color: #444;
  opacity: 1;
  transition: color 0.2s, opacity 0.2s;
}
.custom-switch .switch-option.inactive {
  color: #444;
  opacity: 0.6;
  font-weight: 600;
}
.custom-switch {
  min-width: 110px;
  max-width: 180px;
  width: fit-content;
  margin: 0 4px;
}
.custom-switch .switch-option {
  min-width: 48px;
  padding: 0 8px;
}
/* Menor para o switch de visualização */
#viewSwitch .switch-option {
  font-size: 1.05rem;
  font-weight: 600;
  letter-spacing: 0.01em;
  padding: 0 10px;
}
#viewSwitch {
  min-width: 150px;
  max-width: 220px;
}
@media (max-width: 700px) {
  .custom-switch {
    min-width: 90px;
    height: 32px;
  }
  .custom-switch .switch-slider {
    height: 26px;
  }
  .custom-switch .switch-option {
    font-size: 1rem;
    line-height: 26px;
  }
  #viewSwitch {
    min-width: 110px;
  }
}
  /* Custom Switches estilo slider translúcido */
  .custom-switch {
    display: inline-flex;
    align-items: center;
    background: #ededed;
    border-radius: 24px;
    border: 1.5px solid #d2d2d2;
    padding: 2px 4px;
    min-width: 110px;
    height: 38px;
    position: relative;
    font-size: 1.18rem;
    font-family: inherit;
    box-shadow: 0 2px 8px #0001;
    user-select: none;
    transition: background 0.2s;
  }
  .custom-switch input[type="radio"] {
    display: none;
  }
  .custom-switch label {
    flex: 1 1 0;
    text-align: center;
    z-index: 2;
    cursor: pointer;
    color: #444;
    font-weight: bold;
    padding: 0 8px;
    transition: color 0.2s;
    line-height: 34px;
    position: relative;
  }
  .custom-switch label[for^="scalePercent"],
  .custom-switch label[for^="viewBar"] {
    border-top-left-radius: 20px;
    border-bottom-left-radius: 20px;
  }
  .custom-switch label[for^="scale05"],
  .custom-switch label[for^="viewDist"] {
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
  }
  .custom-switch input[type="radio"]:checked + label {
    background: #cbe3f8;
    color: #2196f3;
    font-weight: bold;
    box-shadow: 0 2px 8px #2196f322;
    transition: background 0.2s, color 0.2s;
  }
  .custom-switch label:not(:first-of-type) {
    margin-left: -4px;
  }
  .custom-switch label {
    transition: background 0.2s, color 0.2s;
  }
  @media (max-width: 600px) {
    .custom-switch { min-width: 80px; font-size: 1rem; height: 32px; }
    .custom-switch label { line-height: 28px; padding: 0 4px; }
  }
  </style>
</head>
<body>
<aside class="sidebar">
  <div>
    <div class="sidebar-header">
      <h2>EVAL DASHBOARD</h2>
      <h3>Kitchen Assistant</h3>
    </div>
    <nav class="sidebar-nav" id="nav">
      <a href="#performance-overall" onclick="setActive(this)">Classificação Geral</a>
      <a href="#user-opinions" onclick="setActive(this)">Opiniões dos Utilizadores</a>
      <a href="#task-performance" onclick="setActive(this)">Desempenho nas Tarefas</a>
      <a href="#confidence-level" onclick="setActive(this)">Nível de Confiança</a>
      <a href="#justifications" onclick="setActive(this)">Justificações</a>
    </nav>
  </div>
  <button class="btn-logout" onclick="logout()">Logout</button>
</aside>
<main class="content">
  <section id="performance-overall" class="chart-box">
    <h2 class="chart-title">Desempenho Geral</h2>
    <div class="chart-group">
      <div class="chart-item"><div id="gaugeChart" style="width:100%;height:500px;"></div></div>
    </div>
  </section>
  <section id="user-opinions" class="chart-box">
    <h2 class="chart-title">Opiniões dos Utilizadores</h2>
    <div style="text-align:center; margin-bottom: 20px;">
      <label for="userSelect" style="font-size:1.1rem; margin-right:10px;">Universo de utilizadores:</label>
      <select id="userSelect" style="font-size:1.1rem; margin-right:20px;"></select>
      <!-- Switches modernos -->
      <div id="switches-row" style="display:inline-flex; gap:18px; vertical-align:middle;">
        <div class="custom-switch" id="scaleSwitch">
          <input type="radio" id="scalePercent" name="scaleSwitch" checked>
          <label for="scalePercent">%</label>
          <input type="radio" id="scale05" name="scaleSwitch">
          <label for="scale05">0-5</label>
        </div>
        <div class="custom-switch" id="viewSwitch">
          <input type="radio" id="viewBar" name="viewSwitch" checked>
          <label for="viewBar">Barras</label>
          <input type="radio" id="viewDist" name="viewSwitch">
          <label for="viewDist">Distribuição</label>
        </div>
      </div>
    </div>
    <div class="chart-item"><canvas id="metricsChart"></canvas></div>
    <div id="metricsBarLabels" style="display:flex;justify-content:space-between;align-items:flex-start;margin-top:8px;"></div>
  </section>
  <section id="task-performance" class="chart-box">
    <h2 class="chart-title">Desempenho nas Tarefas</h2>
    <div id="stackedLineChart"></div>
  </section>
  <section id="confidence-level" class="chart-box">
    <h2 class="chart-title">Nível de Confiança</h2>
    <div class="chart-item"><canvas id="randomLineChart"></canvas></div>
  </section>
  <section id="justifications" class="chart-box">
    <h2 class="chart-title">Justificações de Feedback</h2>
    <div id="justificacoes-container">
      <div class="filter-row">
        <label>De:<input type="date" id="filtroDataInicio"></label>
        <label>Até:<input type="date" id="filtroDataFim"></label>
        <label>Classificação:
          <select id="filtroClassificacao">
            <option value="">Todas</option>
            <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
          </select>
        </label>
        <button onclick="fetchJustificacoes()">Filtrar</button>
      </div>
      <table>
        <thead><tr><th>Data</th><th>Pergunta</th><th>Classificação</th><th>Justificação</th></tr></thead>
        <tbody id="justificacoes-list"></tbody>
      </table>
    </div>
  </section>
</main>
<script>
  Chart.defaults.font.size = 20;
  Chart.defaults.font.family = 'Arial';
  Chart.register(ChartDataLabels);

  function setActive(el) {
    document.querySelectorAll('.sidebar-nav a').forEach(a => a.classList.remove('active'));
    el.classList.add('active');
  }

  function logout() {
    fetch('/api/logout', { method: 'POST', credentials: 'include' })
      .then(() => location.href = '/login');
  }

  function updateGaugeChart(val) {
  // Garante que o container existe e está limpo
  const gaugeDiv = document.getElementById('gaugeChart');
  if (!gaugeDiv) return;
  gaugeDiv.innerHTML = '';
  const gauge = echarts.init(gaugeDiv);
  let label, color;
  if (val < 20) {
    label = 'Muito Mau'; color = '#b50000';
  } else if (val < 40) {
    label = 'Mau'; color = '#ea6d1c';
  } else if (val < 60) {
    label = 'Mediocre'; color = '#FFD700';
  } else if (val < 80) {
    label = 'Bom'; color = '#92d663';
  } else {
    label = 'Excelente'; color = '#019e04';
  }
  gauge.setOption({
    series: [{
      type: 'gauge',
      startAngle: 180,
      endAngle: 0,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        lineStyle: {
          width: 8,
          color: [
            [0.2, '#b50000'],
            [0.4, '#ea6d1c'],
            [0.6, '#FFD700'],
            [0.8, '#92d663'],
            [1, '#019e04']
          ]
        }
      },
      pointer: {
        length: '55%',
        width: 10,
        offsetCenter: ['0', '-15%'],
        itemStyle: { color: 'auto' }
      },
      axisLabel: {
        distance: -50,
        fontSize: 16,
        formatter: '{value}'
      },
      detail: {
        offsetCenter: ['0', '40%'],
        fontSize: 24,
        valueAnimation: true,
        formatter: ` {b|${label}}\n  {c|${val}%}`,
        rich: {
          b: { fontWeight: 'bold', fontSize: 32, color: color },
          c: { fontWeight: 'bold', fontSize: 32, color: color }
        }
      },
      data: [{ value: val, name: '' }]
    }]
  });
}

  let metricsData = null;
  let showPercent = true;
  let showSwarmplot = false;
  let selectedUser = "Todos";

  function updateMetricsChart(metrics, rawFeedbacks) {
    metricsData = metrics;
    const barDiv = document.getElementById('metricsChart');
    const swarmDivId = 'swarmplotDiv';
    // Remove previous swarmplot if exists
    let oldSwarm = document.getElementById(swarmDivId);
    if (oldSwarm) oldSwarm.remove();

    if (window.metricsChartInstance) window.metricsChartInstance.destroy();

    if (!showSwarmplot) {
      // Bar chart mode
      barDiv.style.display = '';
      let dataArr = showPercent
        ? [metrics.facil_de_usar, metrics.estou_satisfeito, metrics.usaria_novamente, metrics.comunica_bem, metrics.faz_oque_quero]
        : [metrics.facil_de_usar, metrics.estou_satisfeito, metrics.usaria_novamente, metrics.comunica_bem, metrics.faz_oque_quero].map(v => +(v/20).toFixed(2));
      let yMax = showPercent ? 100 : 5;
      let yLabel = showPercent ? 'Percentagem (%)' : 'Escala (0-5)';
      // Cada barra é um dataset para permitir toggle na legenda
      const barColors = ['#FF6384','#36A2EB','#FFCE56','#4BC0C0','#9966FF'];
      const barLabels = ['Fácil de Usar','Estou Satisfeito','Usaria Novamente','Comunica Bem','Faz o que eu quero'];
      const datasets = barLabels.map((label, i) => ({
        label: label,
        data: [dataArr[i]],
        backgroundColor: barColors[i],
        datalabels: {
          anchor: 'center', align: 'center', color: '#fff', font: { size: 18, weight: 'bold' },
          formatter: v => showPercent ? (v + '%') : v
        }
      }));
      window.metricsChartInstance = new Chart(barDiv.getContext('2d'), {
        type: 'bar',
        data: {
          labels: [''], // Corrigir: apenas um grupo, cada barra é um dataset
          datasets: datasets
        },
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: yMax,
              min: 0,
              suggestedMin: 0
            }
          },
          plugins: {
            legend: { display: true, position: 'top', labels: { font: { size: 16 } },
              onClick: (e, legendItem, legend) => {
                const ci = legend.chart;
                const dsIndex = legendItem.datasetIndex;
                const meta = ci.getDatasetMeta(dsIndex);
                meta.hidden = meta.hidden === null ? !ci.data.datasets[dsIndex].hidden : null;
                ci.update();
                updateBarLabels(ci);
              }
            },
            datalabels: { display: true }
          }
        },
        plugins: [{
          id: 'barLabelBase',
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;
            ctx.save();
            const metas = chart.getSortedVisibleDatasetMetas();
            metas.forEach((meta) => {
              const bar = meta.data[0];
              if (!bar) return;
              const datasetIndex = meta.index;
              let label = chart.data.datasets[datasetIndex].label;
              // Forçar quebra manual para "Faz o que eu quero"
              if (label === 'Faz o que eu quero') {
                label = 'Faz o que\neu quero';
              }
              // Medir largura da barra em tempo real
              let barWidth = 0;
              if (bar.width) {
                barWidth = bar.width;
              } else if (bar.x !== undefined && bar.base !== undefined) {
                barWidth = Math.abs(bar.base - bar.x) * 2;
              } else {
                barWidth = 40;
              }
              // Ajustar fonte e dividir em 2 linhas se necessário
              let fontSize = 15;
              ctx.font = `bold ${fontSize}px Arial`;
              let labelLines = label.split('\n');
              let textWidth = Math.max(...labelLines.map(l => ctx.measureText(l).width));
              // Se o texto não cabe, tenta dividir automaticamente
              if (textWidth > barWidth - 8 && labelLines.length === 1) {
                // Tenta dividir em 2 linhas na palavra do meio
                const words = label.split(' ');
                if (words.length > 2) {
                  const mid = Math.floor(words.length/2);
                  labelLines = [words.slice(0,mid).join(' '), words.slice(mid).join(' ')];
                  textWidth = Math.max(...labelLines.map(l => ctx.measureText(l).width));
                }
              }
              // Reduzir tamanho da fonte se ainda não couber
              if (textWidth > barWidth - 8) {
                ctx.font = `bold 13px Arial`;
                if (labelLines.some(l => ctx.measureText(l).width > barWidth - 8)) {
                  ctx.font = `bold 11px Arial`;
                }
              }
              // Desenhar as linhas centradas acima do score
              const x = bar.x;
              let y = bar.y - 28;
              ctx.fillStyle = '#222';
              ctx.textAlign = 'center';
              labelLines.forEach((line, idx) => {
                ctx.fillText(line, x, y + idx*15);
              });
            });
            ctx.restore();
          }
        }]
      });
      updateBarLabels(window.metricsChartInstance);
      document.getElementById('toggleScaleBtn').innerText = showPercent ? 'Mostrar em escala 0-5' : 'Mostrar em percentagem';
      document.getElementById('toggleSwarmBtn').innerText = 'Mostrar Swarmplot';
    } else {
      // Swarmplot/Boxplot com barras de fundo
      barDiv.style.display = 'none';
      let swarmDiv = document.createElement('div');
      swarmDiv.id = swarmDivId;
      swarmDiv.style.width = '100%';
      swarmDiv.style.height = '500px';
      barDiv.parentNode.insertBefore(swarmDiv, barDiv.nextSibling);
      let metricNames = ['facil_de_usar','estou_satisfeito','usaria_novamente','comunica_bem','faz_oque_quero'];
      let labels = ['Fácil de Usar','Estou Satisfeito','Usaria Novamente','Comunica Bem','Faz o que eu quero'];
      let colors = ['#FF6384','#36A2EB','#FFCE56','#4BC0C0','#9966FF'];
      // Barras de fundo (médias)
      let barMeans = metricNames.map(m => showPercent ? metrics[m] : +(metrics[m]/20).toFixed(2));
      let barTrace = {
        x: labels,
        y: barMeans,
        type: 'bar',
        marker: { color: colors, opacity: 0.25 },
        name: 'Média',
        width: 0.6,
        hoverinfo: 'y',
        showlegend: false,
        text: barMeans.map(v => v.toFixed(2)),
        textposition: 'inside',
        textfont: { size: 18, color: '#222', family: 'Arial' }
      };
      // Swarm/boxplot por cima
      let traces = metricNames.map((m, i) => {
        let vals = (rawFeedbacks && rawFeedbacks[m]) ? rawFeedbacks[m] : [];
        let plotVals = vals.map(v => showPercent ? v*20 : v);
        return {
          y: plotVals,
          x: Array(plotVals.length).fill(labels[i]),
          name: labels[i],
          type: 'box',
          boxpoints: 'all',
          jitter: 0.5,
          pointpos: 0,
          marker: { color: '#222', size: 8, opacity: 0.7 },
          line: { color: colors[i] },
          fillcolor: colors[i]+"33",
          opacity: 1,
          width: 0.5,
          showlegend: false
        };
      });
      let yMax = showPercent ? 100 : 5;
      let yLabel = showPercent ? 'Percentagem (%)' : 'Escala (0-5)';
      let plotData = [barTrace, ...traces];
      let layout = {
        title: 'Distribuição das Opiniões dos Utilizadores',
        yaxis: { title: yLabel, range: [0, yMax] },
        boxmode: 'group',
        barmode: 'overlay',
        margin: { t: 60, l: 60, r: 30, b: 60 },
        font: { size: 18 },
        xaxis: { tickfont: { size: 13 } } // <-- labels mais pequenas
      };
      if(typeof Plotly==='undefined'){
        let s=document.createElement('script');
        s.src='https://cdn.plot.ly/plotly-latest.min.js';
        s.onload=()=>Plotly.newPlot(swarmDivId, plotData, layout, {responsive:true});
        document.body.appendChild(s);
      }else{
        Plotly.newPlot(swarmDivId, plotData, layout, {responsive:true});
      }
      document.getElementById('toggleSwarmBtn').innerText = 'Mostrar Barras';
      document.getElementById('toggleScaleBtn').innerText = showPercent ? 'Mostrar em escala 0-5' : 'Mostrar em percentagem';
    }
  }

  // Atualiza os títulos das métricas visíveis, alinhados com as barras
  function updateBarLabels(chart) {
    const labelsDiv = document.getElementById('metricsBarLabels');
    labelsDiv.innerHTML = '';
    // Para cada barra (posição), verifica se está visível
    const metas = chart.getSortedVisibleDatasetMetas();
    const datasets = chart.data.datasets;
    const barLabels = chart.data.labels;
    for (let i = 0; i < barLabels.length; i++) {
      // Se a barra correspondente está oculta, mostra label esbatida
      const meta = chart.getDatasetMeta(i);
      const div = document.createElement('div');
      div.textContent = barLabels[i];
      div.style.flex = '1 1 0';
      div.style.textAlign = 'center';
      div.style.fontWeight = 'bold';
      div.style.fontSize = '16px';
      div.style.color = meta.hidden ? '#bbb' : '#111';
      div.style.opacity = meta.hidden ? '0.5' : '1';
      labelsDiv.appendChild(div);
    }
  }

  function toggleScale() {
    showPercent = !showPercent;
    if(metricsData) fetchMetrics();
  }

  function toggleSwarmplot() {
    showSwarmplot = !showSwarmplot;
    if(metricsData) fetchMetrics();
  }

  // Substituir a função updateStackedLineChart para usar apenas dados reais do backend
  async function updateStackedLineChart() {
    const dom = document.getElementById('stackedLineChart');
    const chart = echarts.init(dom);
    try {
      const r = await fetch('/api/task_metrics');
      const data = await r.json();
      // data: { 'YYYY-MM-DD': {gestao_despensa: 4, receitas: 3, lista_compras: 5}, ... }
      const days = Object.keys(data).sort();
      const tarefas = ['gestao_despensa', 'receitas', 'lista_compras'];
      const nomes = ['Gestão de Despensa', 'Receitas', 'Lista de Compras'];
      const cores = ['#4BC0C0', '#FFCE56', '#36A2EB'];
      const series = tarefas.map((t, i) => ({
        name: nomes[i],
        type: 'line',
        data: days.map(d => data[d][t] != null ? data[d][t] : null),
        lineStyle: { width: 3, color: cores[i] },
        connectNulls: true
      }));
      chart.setOption({
        tooltip: { trigger: 'axis' },
        legend: { data: nomes, textStyle: { fontSize: 16 } },
        xAxis: { type: 'category', data: days, axisLabel: { fontSize: 16, rotate: 30 } },
        yAxis: { type: 'value', min: 0, max: 5, axisLabel: { fontSize: 16 } },
        series,
        toolbox: { feature: { saveAsImage: {} } }
      });
    } catch (e) {
      dom.innerHTML = '<div style="color:red">Erro ao carregar dados de desempenho diário.</div>';
      console.error(e);
    }
  }

  function updateRandomLineChart(monthly) {
    const ctx = document.getElementById('randomLineChart').getContext('2d');
    new Chart(ctx,{type:'line',data:{labels:Object.keys(monthly),datasets:[{data:Object.values(monthly),borderWidth:3,fill:false}]},options:{responsive:true,maintainAspectRatio:false,scales:{y:{beginAtZero:true,max:100}}}});
  }

  function onScroll() {
    const sections=document.querySelectorAll('main.content section'); const links=document.querySelectorAll('.sidebar-nav a'); let pos=window.scrollY+200;
    sections.forEach(sec=>{ if(sec.offsetTop<=pos && sec.offsetTop+sec.offsetHeight>pos){ links.forEach(l=>l.classList.remove('active')); document.querySelector(`.sidebar-nav a[href='#${sec.id}']`).classList.add('active'); }});
  }

  async function fetchUsers() {
    try {
      const r = await fetch('/api/users', {credentials:'include'});
      const users = await r.json();
      const sel = document.getElementById('userSelect');
      sel.innerHTML = '';
      users.forEach(u => {
        const opt = document.createElement('option');
        opt.value = u;
        opt.textContent = u;
        sel.appendChild(opt);
      });
      sel.onchange = function() {
        selectedUser = this.value;
        fetchMetrics();
      };
    } catch(e) { console.error(e); }
  }

  async function fetchMetrics(){
    try{
      let url = '/api/metrics';
      let rawUrl = '/api/metrics_raw';
      if(selectedUser && selectedUser !== 'Todos'){
        url += '?user=' + encodeURIComponent(selectedUser);
        rawUrl += '?user=' + encodeURIComponent(selectedUser);
      }
      const r=await fetch(url,{credentials:'include'}),d=await r.json();
      let raw = {};
      try {
        const r2 = await fetch(rawUrl,{credentials:'include'});
        raw = await r2.json();
      } catch(e) { raw = {}; }
      updateMetricsChart(d, raw);
      // Corrigir: garantir que o gauge é atualizado e visível
      const ov = Math.round((d.facil_de_usar + d.estou_satisfeito + d.usaria_novamente + d.comunica_bem + d.faz_oque_quero)/5);
      setTimeout(() => updateGaugeChart(ov), 100);
    }catch(e){console.error(e);}
  }
  async function fetchJustificacoes(){ try{ const r=await fetch('/api/justificacoes'),arr=await r.json(),f1=document.getElementById('filtroDataInicio').value,f2=document.getElementById('filtroDataFim').value,cls=document.getElementById('filtroClassificacao').value,t1=f1?new Date(f1).getTime():0,t2=f2?new Date(f2).getTime()+86400000:Infinity,fil=arr.filter(i=>{const ts=new Date(i.timestamp).getTime();return ts>=t1&&ts<t2&&(!cls||i.resposta==cls);}),tb=document.getElementById('justificacoes-list'); tb.innerHTML=''; if(!fil.length){tb.innerHTML='<tr><td colspan="4">Nenhuma justificação encontrada.</td></tr>';return;} fil.forEach(i=>{const tr=document.createElement('tr');tr.innerHTML=`<td>${new Date(i.timestamp).toLocaleString('pt-PT')}</td><td>${i.pergunta}</td><td>${i.resposta}</td><td>${i.justificacao}</td>`;tb.appendChild(tr);});}catch(e){console.error(e);} }

  document.addEventListener('DOMContentLoaded',()=>{ setActive(document.querySelector('.sidebar-nav a')); updateStackedLineChart(); fetchUsers(); fetchMetrics(); fetchJustificacoes(); window.addEventListener('scroll', onScroll); });
 // Scroll suave ao clicar nos links da sidebar
 document.querySelectorAll('.sidebar-nav a').forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        const targetId = link.getAttribute('href').substring(1);
        const section = document.getElementById(targetId);
        if (section) section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        setActive(link);
      });
    });
; setActive(this);

// --- Custom Switches para escala e visualização ---
function setSwitchState() {
  // Escala
  document.getElementById('scalePercent').checked = showPercent;
  document.getElementById('scale05').checked = !showPercent;
  // Visualização
  document.getElementById('viewBar').checked = !showSwarmplot;
  document.getElementById('viewDist').checked = showSwarmplot;
}
function setupCustomSwitches() {
  setSwitchState();
  document.getElementById('scalePercent').onclick = () => {
    if (!showPercent) { showPercent = true; fetchMetrics(); setSwitchState(); }
  };
  document.getElementById('scale05').onclick = () => {
    if (showPercent) { showPercent = false; fetchMetrics(); setSwitchState(); }
  };
  document.getElementById('viewBar').onclick = () => {
    if (showSwarmplot) { showSwarmplot = false; fetchMetrics(); setSwitchState(); }
  };
  document.getElementById('viewDist').onclick = () => {
    if (!showSwarmplot) { showSwarmplot = true; fetchMetrics(); setSwitchState(); }
  };
}
document.addEventListener('DOMContentLoaded',()=>{
  setActive(document.querySelector('.sidebar-nav a'));
  updateStackedLineChart();
  fetchUsers();
  fetchMetrics();
  fetchJustificacoes();
  window.addEventListener('scroll', onScroll);
  setTimeout(() => { removeOldSwitchButtons(); setupCustomSwitches(); }, 100);
});
</script>
<script src="updateStackedLineChart.js"></script>
</body>
</html>
